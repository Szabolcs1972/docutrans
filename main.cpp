#include <iostream>
#include <sstream>
#include <vector>
#include <fstream>
#include <istream>
#include <string>
#include <cstring>
#include <math.h>

using namespace std;

class dokutrans {

    //get the line of the text file
    string row;
    //store the rows of the file in this vector
    vector<string> rows;
    //store integers from csv file generated by IrfranView
    vector<int> responseX;
    vector<int> responseY;


public:
    //getters
    const vector<string> &getRows() const {
        return rows;
    }

    const vector<int> &getResponseX() const {
        return responseX;
    }

    const vector<int> &getResponseY() const {
        return responseY;
    }
    //constructor for text transforms
    dokutrans(string filename) {

        try {

            ifstream file (filename);

            if (file) {

                if (file.is_open()) {

                    while (!file.eof()) {

                            getline(file, row);
                            cout << row << endl;

                            rows.push_back(row);

                    }

                }
            } else {
                cerr << "A fájl nem található, vagy nem nyitható meg!" << "\n";
            }
            //cout << "We are here!" << endl;
            file.close();

        }  catch (exception &e) {
            cerr << "Hiba történt!" << e.what() << "\n";
        }

    }

    //constructor for csv - generated by IrfranView
    //we would like to skip the first line. It is containing the column names.
    dokutrans(string filename, string irfran) {

        int lines = 0;
        string firstline;

        try {

            ifstream file (filename);

            if (file) {

                if (file.is_open()) {

                    while (!file.eof()) {
                        //cout << "We are here!" << endl;
                        //we don't read the first line of the csv, it is containing the names of the columns
                        if (lines == 0) {

                            getline(file, firstline);
                            lines++;

                        } else {

                            getline(file, row);
                            //cout << row << endl;

                            rows.push_back(row);

                        }

                    }

                }
            } else {
                cerr << "A fájl nem található, vagy nem nyitható meg!" << "\n";
            }
            //cout << "We are here!" << endl;
            file.close();

        }  catch (exception &e) {
            cerr << "Hiba történt!" << e.what() << "\n";
        }

    }

    //method to convert the chars to uppercase
    string convertToUpper(string s) {

        for (int i = 0; i<s.length();i++) {
            if (s[i] >= 'a' && s[i] <= 'z') {
                s[i] = (char) (s[i] - 'a' + 'A');
            }
        }

        return s;
    }

    //method to convert the first chars of the words to uppercase
    string firstToCapitalize(string s) {

        unsigned long start = 0, pos_end;
        string token;
        string last;
        string response;

        while ((pos_end = s.find(" ", start)) != string::npos) {
            token = s.substr (start, ((pos_end+1) - start));
            start = pos_end + 1;
            //cout << token.length() << endl;

            if (token[0] >= 'a' && token[0] <= 'z') {
                token[0] = (char) (token[0] - 'a' + 'A');
            }

            //cout << token << endl;
            response += token;
        }

        last = s.substr (start);
        //cout << last.length() << endl;

        if (last[0] >= 'a' && last[0] <= 'z') {
            last[0] = (char) (last[0] - 'a' + 'A');
        }

        //cout << last << endl;
        response += last;

        return response;
    }

    //method to merge the words in a form of camelCase
    string convertTocamelCase(string s) {

        //start and end of the substring
        unsigned long start = 0, end;
        //we count the number of the word in the sentence, the first character of the odds - lowercase, the first character of the evens - uppercase
        int wordCounter = 1;
        //the substring from the start till the delimiter
        string token;
        //the last string in the row
        string last;
        //the string to return
        string response;


        while ((end = s.find_first_of(" ", start)) != string::npos) {

            if ((s.at((int) end-1) == '.') || (s.at((int) end-1) == '?') || (s.at((int) end-1) == '!') || (s.at((int) end-1) == ',')) {
                token = s.substr (start, ((end+1) - start));
                start = end + 1;
                //cout << s.at((int) end) << endl;

                if (wordCounter % 2 == 0) {
                    if (token[0] >= 'a' && token[0] <= 'z') {
                        token[0] = (char) (token[0] - 'a' + 'A');
                    }
                }  else {
                    if (token[0] >= 'A' && token[0] <= 'Z') {
                        token[0] = (char) (token[0] + 'a' - 'A');
                    }
                }
                //cout << token << endl;

                response += token;
                //we start to count the number of the words again, when we have a new sentence or sub-sentence
                wordCounter = 1;
            } else {
                token = s.substr (start, ((end) - start));
                start = end + 1;
                //cout << s.at((int) end) << endl;

                if (wordCounter % 2 == 0) {
                    if (token[0] >= 'a' && token[0] <= 'z') {
                        token[0] = (char) (token[0] - 'a' + 'A');
                    }
                }  else {
                    if (token[0] >= 'A' && token[0] <= 'Z') {
                        token[0] = (char) (token[0] + 'a' - 'A');
                    }
                }
                //cout << token << endl;
                response += token;
                //we have space between the words, we can continue to count the number of the words
                wordCounter++;
            }

        }

        last = s.substr (start);
        //cout << last.length() << endl;

        if (wordCounter % 2 == 0) {
            if (last[0] >= 'a' && last[0] <= 'z') {
                last[0] = (char) (last[0] - 'a' + 'A');
            }
        }  else {
            if (last[0] >= 'A' && last[0] <= 'Z') {
                last[0] = (char) (last[0] + 'a' - 'A');
            }
        }
        //cout << last << endl;
        response += last;


        return response;
    }

    //push the integers after the 8th and 9th comma to store in vectors
    void splitToImageSizes(string s) {

        unsigned long start = 0, end;
        string token;
        stringstream sponge;
        int x = 0;
        int y = 0;
        //string response;
        vector<string> response;


        int numberOfComma = 0;

        while ((end = s.find(",", start)) != string::npos) {
            numberOfComma++;
            token = s.substr (start, ((end) - start));

            start = end + 1;
            if (numberOfComma == 8) {
                for (char c : token) {
                    // Checking if the element is number
                    if (c >= '0' && c <= '9') {
                        x = x * 10 + (c - '0');
                    }
                }
                //cout << "Ez az x-em: " << x << endl;
                responseX.push_back(x);
                //response.push_back(token);
            }
            if (numberOfComma == 9) {
                for (char c : token) {
                    // Checking if the element is number
                    if (c >= '0' && c <= '9') {
                        y = y * 10 + (c - '0');
                    }
                }

                //y = stoi(token);
                responseY.push_back(y);
                //response.push_back(token);
            }

        }

    }
    //calculate the averages of the width and height of pics in pixels
    int averages(vector<int> vector1) {
        float sum = 0.0;
        int size = vector1.size();

        for (int i : vector1) {
            sum += i;
        }

        return round((sum / (float) size));

    }
    //text transforms according to the -t switches
    //return vector to save the transforms in a new file - "transformed.txt"
    //the file is going to be overwritten, if it is exists

    vector<string> textTransforms(bool upper,bool capitalize,bool camelcase,vector<string> toBeTransformed) {
        vector<string> response;
        string transformed;

        if (upper) {
            int i = 0;
            for (string s : toBeTransformed) {
                transformed = convertToUpper(s);
                toBeTransformed.at(i) = transformed;
                i++;
            }
            transformed = "";
        }
        if (capitalize) {
            int j = 0;
            for (string s : toBeTransformed) {
                transformed = firstToCapitalize(s);
                toBeTransformed.at(j) = transformed;
                j++;
            }
            transformed = "";
        }
        if (camelcase) {
            int k = 0;
            for (string s : toBeTransformed) {
                transformed = convertTocamelCase(s);
                toBeTransformed.at(k) = transformed;
                k++;
            }
            transformed = "";
        }
        //print out the results of the transformations
        for (string s : toBeTransformed) {
            cout << s << endl;
            response.push_back(s);
        }
        return response;
    }


};


int main(int argc,char* args[]) {

    //to store the name of the file in a string
    string filename;
    //booleans to store the positions of the switches
    bool is_exist_filename = false;
    bool is_exist_tSwitch_command = false;
    bool i_switch = false;
    bool t_switch = false;
    bool UPPER = false;
    bool Capitalize = false;
    bool camelCase = false;
    bool irfran = false;

    //cout << argc << endl;
    for (int i=1; i<argc;i++) {

        //cout << args[i] << endl;
        if ((string) args[i] == "-i") {
            i_switch = true;

            //make sure there is something after the -i switch, before get a filename as a string
            //and there is no other swith after -i
            if (i+1 <= argc-1) {
                if ((string) args[i + 1] != "-t" || (string) args[i + 1] != "upper"
                    || (string) args[i + 1] != "capitalize" || (string) args[i + 1] != "camelcase"
                    || (string) args[i + 1] != "upper") {
                    filename = (string) args[i + 1];
                    is_exist_filename = true;
                    cout << filename << endl;
                }
            }

        }

        if ((string) args[i] == "-t") {
            t_switch = true;
            for (int i=1; i<argc;i++) {

               if ((string) args[i] == "upper") {
                   UPPER = true;
                   is_exist_tSwitch_command = true;
               } else if ((string) args[i] == "capitalize") {
                   Capitalize = true;
                   is_exist_tSwitch_command = true;
               } else if ((string) args[i] == "camelcase") {
                   camelCase = true;
                   is_exist_tSwitch_command = true;
               } else if ((string) args[i] == "irfran") {
                   irfran = true;
                   is_exist_tSwitch_command = true;
                   UPPER = false;
                   Capitalize = false;
                   camelCase = false;
               }

            }

        }



    }

    if (i_switch && t_switch) {

        if (is_exist_filename) {
            if (is_exist_tSwitch_command) {

                 if (irfran) {
                     dokutrans dt = dokutrans(filename, "irfran");
                     if (!dt.getRows().empty()) {
                         for (string s: dt.getRows()) dt.splitToImageSizes(s);

                         cout << "X koordináták (szélesség) átlaga: " << dt.averages(dt.getResponseX()) << " pixel." << endl;
                         cout << "Y koordináták (magasság) átlaga: " << dt.averages(dt.getResponseY()) << " pixel." << endl;
                     } else {
                         cerr << "A feldolgozandó fájl valószínűleg üres!";
                     }
                 }

                 if (UPPER || Capitalize || camelCase) {
                     //we would like to process all of the rows, we call the other constructor for text transforms
                     dokutrans dt = dokutrans(filename);
                     if (!dt.getRows().empty()) {

                     vector<string> out = dt.textTransforms(UPPER,Capitalize,camelCase,dt.getRows());
                         //for (string s: dt.getRows()) cout << dt.convertToUpper(s) << endl;
                        try {
                            ofstream file_out ("transformed.txt");
                            if (file_out) {
                                if (file_out.is_open()) {
                                    for (string s: out) file_out << s;
                                }
                                file_out.close();
                                }

                            } catch (exception &e) {
                            cerr << "Hiba történt!" << e.what() << "\n";
                        }
                         //cout << upperized << endl;
                         //cout << "Y koordináták átlaga: " << dt.averages(dt.getResponseY()) << endl;
                     } else {
                         cerr << "A feldolgozandó fájl valószínűleg üres!";
                     }
                 }
            } else {
                cout << "A -t kapcsoló után nem adtad meg a feldolgozás módját!" << endl;
            }
        } else {
            cout << "Az -i kapcsoló után nem adtad meg a feldolgozandó állomány nevét!" << endl;
        }

    } else {
        cout << "A 'dokutrans' program kapcsolói:" << endl;
        cout << "-i <<a feldolgozandó szöveges állomány neve>>" << endl;
        cout << "-t kapcsoló után:" << endl;
        cout << "upper - szöveg átalakítása nagybetüsre." << endl;
        cout << "capitalize - a szavak nagybetűvel kezdődnek." << endl;
        cout << "camelcase - a szavakÖsszeolvasztása camelCase formát követve." << endl;
        cout << "irfran - IrfranView program által generált veszővel elválasztott .csv állomány feldolgozása." << endl;
        cout << "Egy könyvszkenner a felvételek automatikus vágása, és forgatása után különböző méretű képeket készít." << endl;
        cout << "A képekből keseshető pdf állományt szeretnénk készíteni, és egyforma nagyságű képekre van szükség." << endl;
        cout << "A képek egységes méretre hozása előtt szeretnénk tudni, hogy mekkora a képek átlagos szélessége és magassága?" << endl;
        cout << "Parancssorban, a képeket tartalmazó mappában pl.: az 'i_view64.exe *.jpg /info=jpeg_info.csv' parancs segítségével" << endl;
        cout << "lekérdezhetjük a képekről az információkat, vesszővel elválasztott .csv fájlban. Szeretnénk parancssorban gyorsan" << endl;
        cout << "meghatározni a kesesett értékeket, amelyek adtai a 8. és a 9. vessző után következnek a sorokban....." << endl;
    }

    return 0;
}
